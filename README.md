ZWave Serial API Sniffing Journal
========================

These are my notes About ZWave and RaZerry. 

RaZberry
========

A RaZberry hardware solution is a combination of the Raspberry PI motherboard and the RaZberry Z-Wave transceiver daughter board. The daughter board is connected to the mother-board using the General IO Pin header connector of Raspberry PI. This GPIO interface offers Serial TX and RX signals, ground and 3.3 V VCC to power the Z-Wave transceiver board. 

The RaZberry uses the ZM3102 Z-Wave transceiver from Sigma Designs. This module combines a "System on Chip" (SOC) with a 8051 micro controller, the Z-Wave transceiver and some IO interfaces the systems crystal and the SAW antenna filter.


The micro controller of the SOC contains control code that operates the wireless transceiver and handles certain network level operations of Z-Wave. The communication with this code runs over the serial interface. There is a protocol specification for this interface that is issued by the
Manufacturer of the Z-Wave chip Sigma Designs that most of the Z-Wave transceivers on the market (e.g., USB Sticks) use. This interface specification â€” called Sigma Designs Serial API - is not a public document but available under Non Disclosure Agreement only as part of the Sigma Designs Systems Development Kit (SDK). The firmware of RaZberry is based on the SDK Version 4.54 but has enhanced the Sigma Designs Serial API in several ways.


ZWave
=======

Thanks to the folks over at the OpenZwave project I found out that the basis of ZWave is an ITU standard. A little Googling and it appears the standard of interest is ITU-T G.9959 (http://www.itu.int/rec/T-REC-G.9959/en).

Have I mentioned that I love the project Open-ZWave?


Thoughts on Application Design
==============================

I have written my fair share of Wireshark dissectors but I have alway had Wireshark to do the display of those captures. Not sure 

Creating a ZWave sniffer will require the dissector but it will also require some user interface. This may be best split into to project. Similar to TShark (or tcpdump) that does the capture and the user interface application. Initially the UI will just dump to the console or to a file.

or

Maybe I can sort out someway to save the capture in PCAP format and still use Wireshark to decode it?


Future Goals
===============

I would like to make a ZWave decoder that will monitor the serial line and output human readable information about what is being sent.


Documents
=========
* "razberry.pdf" - http://razberry.z-wave.me/docs/razberry.pdf


Capturing serial port data
=========

Install "interceptty".

* http://www.suspectclass.com/sgifford/interceptty/
* unpack
* build it and install the tool

```BASH

# Usage:
# Stop Z-Way process "sudo /etc/init.d/Z-Way stop"
#  > sudo vi /opt/z-way-server/config.xml
# change "/dev/ttyAMA0" to "/tmp/ttyAMA0"
# Run this script
# Start Z-Way "sudo /etc/init.d/Z-Way start"

interceptty -s 'ispeed 115200 ospeed 115200' /dev/ttyAMA0 /tmp/ttyAMA0

```

Once you are done sniffing the serial port you will need to stop the Z-Way server and change "config.xml" back to it's original form.



Add/Re-Include node to network
========

The following data is sent/receive on the RaZberry board.

This is some scratch data to try and manually decode what the binary packets actually mean.

_Table: First frame sent from controller_

|index|Direction|Value|Decode Information|
|---|---|---|---|
|1 |TX|0x01| |
|2 |TX|0x03| Length? |
|3 |TX|0x00| |
|4 |TX|0x07| |
|5 |TX|0xfb| Checksum - see _Generating a checksum_ below|


_Table: (Switch Binary Set)_

|index|Direction|Value|Decode Information|
|---|---|---|---|
|1  |TX|0x01|Controller? |
|2  |TX|0x0a|Length? |
|3  |TX|0x00| |
|4  |TX|0x13| SendData? |
|5  |TX|0x09|Node ID|
|6  |TX|0x03|3-BinarySet (2-BinaryGet) |
|7  |TX|0x25|BINARY_SWITCH? (0x30 BINARY_SENSOR?)|
|8  |TX|0x01| Set value? (is this [SET, GET, REPORT]?)|
|9  |TX|0x00|0x00-Switch off (0xff=ON) |
|10 |TX|0x25| |
|11 |TX|0x03| |
|12 |TX|0xee|Checksum - see _Generating a checksum_ below|

_Table: Random decodes_

|nodeId|  |  | |  |Description|
|---|---|---|---|---|---|
|18|2|30|2|5|Sensor Binary Get|
|9|3|25|1|ff 25|BINARY_SWITCH Set|
|9|2|25|2|25|BINARY_SWITCH Get|
|9|3|25|1|0 25|BINARY_SWITCH Set|
|9|2|25|2|25|BINARY_SWITCH Get|
|9|3|25|1|0 25|BINARY_SWITCH Set|
|9|2|25|2|25|BINARY_SWITCH Get|

_Raw sample capture_

```
< 0x01
< 0x03
< 0x00
< 0x07
< 0xfb
> 	0x06
> 	0x01
> 	0x2b (+)
> 	0x01
> 	0x07
> 	0x04
> 	0x02
> 	0x01
> 	0x47 (G)
> 	0x00
> 	0x02
> 	0x00
> 	0x03
> 	0xfe
> 	0x00
> 	0x16
> 	0x80
> 	0x0c
> 	0x00
> 	0x00
> 	0x00
> 	0xe3
> 	0x97
> 	0x7d (})
> 	0x80
> 	0x07
> 	0x00
> 	0x00
> 	0x80
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x02
> 	0x00
> 	0x00
> 	0x80
> 	0x07
> 	0x00
> 	0x7c (|)
< 0x06
< 0x01
< 0x05
< 0x00
< 0x06
< 0x0a
< 0x0a
< 0xfc
> 	0x06
> 	0x01
> 	0x05
> 	0x01
> 	0x06
> 	0x0a
> 	0x0a
> 	0xfd
< 0x06
< 0x01
< 0x03
< 0x00
< 0xd2
< 0x2e (.)
> 	0x06
< 0x01
< 0x03
< 0x00
< 0x20
< 0xdc
> 	0x06
> 	0x01
> 	0x08
> 	0x01
> 	0x20
> 	0xf5
> 	0x14
> 	0x67 (g)
> 	0x9b
> 	0x01
> 	0xca
< 0x06
< 0x01
< 0x03
< 0x00
< 0x05
< 0xf9
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x05
> 	0x08
> 	0xf7
< 0x06
< 0x01
< 0x03
< 0x00
< 0x15
< 0xe9
> 	0x06
> 	0x01
> 	0x10
> 	0x01
> 	0x15
> 	0x5a (Z)
> 	0x2d (-)
> 	0x57 (W)
> 	0x61 (a)
> 	0x76 (v)
> 	0x65 (e)
> 	0x20
> 	0x33 (3)
> 	0x2e (.)
> 	0x34 (4)
> 	0x32 (2)
> 	0x00
> 	0x01
> 	0x93
< 0x06
< 0x01
< 0x03
< 0x00
< 0x56 (V)
< 0xaa
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x56 (V)
> 	0x00
> 	0xac
< 0x06
< 0x01
< 0x03
< 0x00
< 0x02
< 0xfe
> 	0x06
> 	0x01
> 	0x25 (%)
> 	0x01
> 	0x02
> 	0x05
> 	0x00
> 	0x1d
> 	0x0f
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x03
> 	0x01
> 	0xcc
< 0x06
< 0x01
< 0x04
< 0x00
< 0x41 (A)
< 0x01
< 0xbb
> 	0x06
> 	0x01
> 	0x09
> 	0x01
> 	0x41 (A)
> 	0x93
> 	0x16
> 	0x00
> 	0x02
> 	0x02
> 	0x01
> 	0x32 (2)
< 0x06
< 0x01
< 0x04
< 0x00
< 0x41 (A)
< 0x02
< 0xb8
> 	0x06
> 	0x01
> 	0x09
> 	0x01
> 	0x41 (A)
> 	0xd2
> 	0x9c
> 	0x00
> 	0x04
> 	0x10
> 	0x01
> 	0xed
< 0x06
< 0x01
< 0x04
< 0x00
< 0x62 (b)
< 0x02
< 0x9b
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x62 (b)
> 	0x00
> 	0x98
< 0x06
< 0x01
< 0x04
< 0x00
< 0x41 (A)
< 0x03
< 0xb9
> 	0x06
> 	0x01
> 	0x09
> 	0x01
> 	0x41 (A)
> 	0x51 (Q)
> 	0x8c
> 	0x00
> 	0x04
> 	0x20
> 	0x01
> 	0x4e (N)
< 0x06
< 0x01
< 0x04
< 0x00
< 0x62 (b)
< 0x03
< 0x9a
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x62 (b)
> 	0x00
> 	0x98
< 0x06
< 0x01
< 0x04
< 0x00
< 0x41 (A)
< 0x04
< 0xbe
> 	0x06
> 	0x01
> 	0x09
> 	0x01
> 	0x41 (A)
> 	0x51 (Q)
> 	0x8c
> 	0x00
> 	0x04
> 	0x20
> 	0x01
> 	0x4e (N)
< 0x06
< 0x01
< 0x04
< 0x00
< 0x62 (b)
< 0x04
< 0x9d
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x62 (b)
> 	0x00
> 	0x98
< 0x06
< 0x01
< 0x06
< 0x00
< 0x80
< 0x01
< 0x00
< 0x00
< 0x78 (x)
> 	0x06
> 	0x01
> 	0x20
> 	0x01
> 	0x80
> 	0x0e
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x50 (P)
< 0x06
< 0x01
< 0x06
< 0x00
< 0x80
< 0x02
< 0x00
< 0x00
< 0x7b ({)
> 	0x06
> 	0x01
> 	0x20
> 	0x01
> 	0x80
> 	0x0d
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x53 (S)
< 0x06
< 0x01
< 0x06
< 0x00
< 0x80
< 0x03
< 0x00
< 0x00
< 0x7a (z)
> 	0x06
> 	0x01
> 	0x20
> 	0x01
> 	0x80
> 	0x03
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x5d (])
< 0x06
< 0x01
< 0x06
< 0x00
< 0x80
< 0x04
< 0x00
< 0x00
< 0x7d (})
> 	0x06
> 	0x01
> 	0x20
> 	0x01
> 	0x80
> 	0x03
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x00
> 	0x5d (])
< 0x06
< 0x01
< 0x0f
< 0x00
< 0x03
< 0x03
< 0x02
< 0x01
< 0x08
< 0x72 (r)
< 0x60 (`)
< 0x86
< 0x8f
< 0x26 (&)
< 0x98
< 0x77 (w)
< 0x20
< 0x09
> 	0x06
< 0x01
< 0x03
< 0x00
< 0x05
< 0xf9
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x05
> 	0x08
> 	0xf7
< 0x06
< 0x01
< 0x07
< 0x00
< 0x54 (T)
< 0x01
< 0x01
< 0x00
< 0x01
< 0xad
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x54 (T)
> 	0x00
> 	0xae
< 0x06
< 0x01
< 0x09
< 0x00
< 0x13
< 0x02
< 0x02
< 0x25 (%)
< 0x02
< 0x25 (%)
< 0x01
< 0xe6
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x13
> 	0x01
> 	0xe8
< 0x06
> 	0x01
> 	0x05
> 	0x00
> 	0x13
> 	0x01
> 	0x00
> 	0xe8
< 0x06
> 	0x01
> 	0x09
> 	0x00
> 	0x04
> 	0x00
> 	0x02
> 	0x03
> 	0x25 (%)
> 	0x03
> 	0x00
> 	0xd5
< 0x06
< 0x01
< 0x0a
< 0x00
< 0x13
< 0x02
< 0x03
< 0x25 (%)
< 0x01
< 0xff
< 0x25 (%)
< 0x02
< 0x1b
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x13
> 	0x01
> 	0xe8
< 0x06
> 	0x01
> 	0x05
> 	0x00
> 	0x13
> 	0x02
> 	0x00
> 	0xeb
< 0x06
< 0x01
< 0x09
< 0x00
< 0x13
< 0x02
< 0x02
< 0x25 (%)
< 0x02
< 0x25 (%)
< 0x03
< 0xe4
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x13
> 	0x01
> 	0xe8
< 0x06
> 	0x01
> 	0x05
> 	0x00
> 	0x13
> 	0x03
> 	0x00
> 	0xea
< 0x06
> 	0x01
> 	0x09
> 	0x00
> 	0x04
> 	0x00
> 	0x02
> 	0x03
> 	0x25 (%)
> 	0x03
> 	0xff
> 	0x2a (*)
< 0x06
> 	0x01
> 	0x08
> 	0x00
> 	0x04
> 	0x00
> 	0x03
> 	0x02
> 	0x84
> 	0x07
> 	0x71 (q)
< 0x06
< 0x01
< 0x09
< 0x00
< 0x13
< 0x03
< 0x02
< 0x84
< 0x08
< 0x05
< 0x04
< 0x69 (i)
> 	0x06
> 	0x01
> 	0x04
> 	0x01
> 	0x13
> 	0x01
> 	0xe8
< 0x06
> 	0x01
> 	0x05
> 	0x00
> 	0x13
> 	0x04
> 	0x00
> 	0xed
< 0x06


```


*Generating a checksum*

```JAVA
    private static byte generateChecksum(byte[] dataFrame) {
        int offset = 0;
        byte ret = data[offset];
        for (int i = offset; i < data.length; i++) {
            // Xor bytes
            ret ^= data[i];
        }
        ret = (byte) (~ret);
        return ret;
    }
    

Usage:
    byte[] zwaveFrame = new byte[] {0x01, 0x03, 0x20, /* (byte) 0xdc, */};
    System.out.println("==============> Checksum: 0x" + Integer.toHexString(EIMApplication.generateChecksum(zwaveFrame)));


```

Device Classes
===========

To allow inter-operability between different Z-Wave devices from different manufacturers, each device must include certain well-defined functions above and beyond the â€˜Basicâ€™ command class.

These requirements are called â€˜Device Classesâ€™. A device class refers to a typical device and defines which command classes that are mandatory for it to support.

Device classes are organized into a three-layer hierarchy:

Every device must belong to a basic device class
Devices can be further specified by assigning them to a generic device class
Further functionality can be defined by assigning the device to a specific device class
Basic Device Class
The â€˜Basicâ€™ device class simply defines a device as a Controller, Slave or Routing Slave. Therefore every device belongs to one basic device class.

Generic Device Class
The â€˜Genericâ€™ device class defines the basic functionality that the devices will support as a controller or slave. Current â€˜Genericâ€™ device classes are:

    General controller (GENERIC_CONTROLLER)
    Static controller (STATIC_CONTROLLER)
    Binary switch (BINARY_SWITCH)
    Multi level switch (MULTI_LEVEL_SWITCH)
    Binary sensor (BINARY_SENSOR)
    Multilevel-Sensor (MULTILEVEL_SENSOR)
    Meter (METER)
    Input controller (ENTRY_CONTROL)
    Thermostat (THERMOSTAT)
    Window Blind controller (WINDOW_COVERING)


_Specific Device Class_

Assigning a â€˜Specificâ€™ device class to a Z-Wave device allows it to further specify its functionality. Each â€˜Genericâ€™ device class refers to a number of specific device classes. You can decide to assign a specific device class, however, it only makes sense if the device really supports all functions of a â€˜Specificâ€™ device class.


JSON Server
========

Z-Way makes a server for Raspberry PI and RaZberry. It seems nice but I don't really have much interest in it. I am a little anti Node.js which is what so many ZWave things seem to be based on?


Terms
========

Term | Description
-----|--------------------
FLIRS | Frequently Listening Devices
NIF | Node Information Frame
SIS | Static ID-Server
SUC | Static Update Controller



More ZWave References
==========
* Catching the Z-Wave - http://www.drdobbs.com/embedded-systems/catching-the-z-wave/193104353
* Open ZWave - https://code.google.com/p/open-zwave/
* An introduction to Z-Wave programming in C# - http://www.digiwave.dk/en/programming/an-introduction-to-z-wave-programming-in-c/
* http://www.vesternet.com/resources/technology-indepth/how-z-wave-controllers-work
